# Сигналы

~~~c
#include <unistd.h>

unsigned int alarm(unsigned int seconds);
~~~
Системный вызов alarm выполняет в вызвавший его процесс доставку сигнала SIGALRM через seconds секунд.
Если seconds равно нулю, то никаких новых тревожных сигналов в очередь поставлено не будет.
Если случится какое-либо событие (интересно какое? -- прим. пер.), любые предыдущие установки alarm отменяются.  

alarm возвращает количество секунд, оставшихся до момента доставки сигнала, установленного предыдущим 
вызовом alarm или ноль, если в очереди нет тревожных сигналов.  

~~~c
#include <unistd.h>

unsigned int sleep(unsigned int seconds);
~~~
sleep() переводит текущий процесс в режим ожидания либо на seconds секунд, либо на время до получения сигнала, который не может быть проигнорирован.  Возвращается ноль, если указанное время истекло, или количество секунд, оставшихся до конца ожидания.  

~~~c
#include <signal.h>
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
~~~
 
Системный вызов signal() устанавливает новый обработчик сигнала с номером signum в соответствии с параметром sighandler, который может быть функцией пользователя, SIG_IGN или SIG_DFL. При получении процессом сигнала с номером signum происходит следующее: если устанавливаемое значение обработчика равно SIG_IGN, то сигнал игнорируется; если оно равно SIG_DFL, то выполняются стандартные действия, связанные с сигналом. Наконец, если обработчик установлен в функцию sighandler, то сначала устанавливает значение обработчика в SIG_DFL или выполняется зависимая от реализации блокировка сигнала, а затем вызывается функция sighandler с параметром signum.

Использование функции-обработчика сигнала называется "перехватом сигнала". Сигналы SIGKILL и SIGSTOP не могут быть "перехвачены" или игнорированы.  

Функция signal() возвращает предыдущее значение обработчика сигнала или SIG_ERR при ошибке.  

# Ссылки

Operating Systems: Three Easy Pieces

https://pages.cs.wisc.edu/~remzi/OSTEP/
